# Readable Code

## LSP

- 상속 구조에서, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.
-> 자식 클래스는 부모 클래스의 책임을 준수하며, 부모 클래스의 행동을 변경하지 않아야 한다.

- LSP를 위반하면, 상속 클래스를 사용할 때 오동작, 예상 밖의 예외가 발생하거나, 이를 방지하기 위한 불필요한 타입 체크가 동반될 수 있다.

## ISP

- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 된다. 
-> 인터페이스를 잘게 쪼개라!
- ISP를 위반하면, 불필요한 의존성으로 인해 결합도가 높아지고, 특정 기능의 변경이 여러 클래스에 영향을 미칠 수 있다.

## DIP

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.
  둘 모두 추상화에 의존해야 한다.
- 의존성의 순방향: 고수준 모듈이 저수준 모듈을 참조하는 것
  의존성의 역방향: 고수준, 저수준 모듈이 모두 추상화에 의존하는 것
  -> 저수준 모듈이 변경되어도, 고수준 모듈에는 영향이 가지 않는다.

## 상속과 조합

- 상속보다 조합을 사용하자!
- 상속은 시멘트처럼 굳어지는 구조다. 수정이 어렵다.
-> 부모와 자식의 결합도가 높다.
- 조합과 인터페이스를 활용하는 것이 유연한 구조
-> 상속을 통한 코드의 중복 제거가 주는 이점보다, 중복이 생기더라도 유연한 구조 설계가 주는 이점이 더 크다.

## Value Object

- 도메인의 어떤 개념을 추상화하여 표현한 값 객체
- 값으로 취급하기 위해서, 불변성, 동등성, 유효성 검증 등을 보장해야 한다.
-> 불변성: final 필드, setter 금지
-> 동등성: 서로 다른 인스턴스여도(동일성이 달라도), 내부의 값이 같으면 같은 값 객체로 취급한다.
          equals() & hashCode() 재정의 필요
-> 유효성 검증: 객체가 생성되는 시점에 값에 대한 유효성을 보장하기

- VO vs Entity
  - Entity는 식별자가 존재한다. 식별자가 아닌 필드의 값이 달라도, 식별자가 같으면 동등한 객체로 취급한다.
  -> equals() & hashCode()도 식별자 필드만 가지고 재정의할 수 있다.
  -> 식별자가 같은데 식별자가 아닌 피르의 값이 서로 다른 두 인스턴스가 있다면, 같은 Entity가 시간이 자남에 따라 변화한 것을 이해할 수도 있다.
  - VO는 식별자 없이, 내부의 모든 값이 다 같아야 동등한 객체로 취급한다
  -> 개념적으로, 전체 필드가 다같이 식별자 역할을 한다고 생각해도 된다.

## 일급 컬렉션

- 컬렉션을 포장하면서, 컬렉션만을 유일하게 필드로 가지는 객체
-> 컬렉션을 다른 객체와 동등한 레벨로 다루기 위함
-> 단 하나의 컬렉션 필드만을 가진다.
- 컬렉션을 추상화하며 의미를 담을 수 있고, 가공 로직의 보금자리가 생긴다.
-> 가공 로직에 대한 테스트도 작성할 수 있다.
- 만약 getter로 컬렉션을 반환할 일이 생긴다면, 외부 조작을 피하기 위해 꼭 새로운 컬렉션으로 만들어서 반환해주자.

## Enum의 특성과 활용

- Enum은 상수의 집합이며, 상수와 관련된 로직을 담을 수 있는 공간이다.
-> 상태와 행위를 한 곳 에서 관리할 수 있는 추상화된 객체
- 특정 도메인 개념에 대해 그 종류와 기능을 명시적으로 표현해줄 수 있다.
- 만약 변경이 정말 잦은 개념은, Enum 보다 DB로 관리하는 것이 나을 수 있다.